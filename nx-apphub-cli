#!/usr/bin/env python3

#############################################################################################################################################################################
#   The license used for this file and its contents is: BSD-3-Clause                                                                                                        #
#                                                                                                                                                                           #
#   Copyright <2024> <Uri Herrera <uri_herrera@nxos.org>>                                                                                                                   #
#                                                                                                                                                                           #
#   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:                          #
#                                                                                                                                                                           #
#    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.                                        #
#                                                                                                                                                                           #
#    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer                                      #
#       in the documentation and/or other materials provided with the distribution.                                                                                         #
#                                                                                                                                                                           #
#    3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software                    #
#       without specific prior written permission.                                                                                                                          #
#                                                                                                                                                                           #
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,                      #
#    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS                  #
#    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE                 #
#    GOODS OR SERVICES; LOSS OF USE, DATA,   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,                      #
#    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   #
#############################################################################################################################################################################

import os
import subprocess
import sys
import shutil
import random
import string
import argparse
import logging
import yaml
import difflib
import hashlib
from concurrent.futures import ThreadPoolExecutor, as_completed


######################
# General functions. #
######################

class NoChoiceHelpFormatter(argparse.RawDescriptionHelpFormatter):
    def _format_action_invocation(self, action):
        if not action.option_strings:
            return super()._format_action_invocation(action)
        else:
            return ', '.join(action.option_strings)

class CustomArgumentParser(argparse.ArgumentParser):
    def __init__(self, *args, **kwargs):
        super(CustomArgumentParser, self).__init__(*args, formatter_class=NoChoiceHelpFormatter, **kwargs)

    def error(self, message):
        if 'install' in message:
            custom_message = "Unspecified command"
        else:
            custom_message = message

        red_color = '\033[91m'
        reset_color = '\033[0m'

        sys.stderr.write(f"{red_color}error:{reset_color}  {custom_message}\n\n")
        sys.stderr.write("See «nx-apphub-cli -h» for help.\n")
        sys.exit(2)

    def format_help(self):
        help_text = super().format_help()
        help_text = help_text.replace('usage:', 'Usage:')
        help_text = help_text.replace('positional arguments:', 'Arguments:')
        help_text = help_text.replace('options:', 'Options:')
        help_text = help_text.replace('show', 'Show')
        return help_text


class ColoredFormatter(logging.Formatter):
    COLOR_CODES = {
        'DEBUG': '\033[94m',     # Blue
        'INFO': '\033[92m',      # Green
        'WARNING': '\033[93m',   # Yellow
        'ERROR': '\033[91m',     # Red
        'CRITICAL': '\033[95m',  # Magenta
    }
    RESET_CODE = '\033[0m'

    def format(self, record):
        color = self.COLOR_CODES.get(record.levelname, self.RESET_CODE)
        message = super().format(record)
        return f"{color}{message}{self.RESET_CODE}"


def setup_logging(log_level):
    numeric_level = getattr(logging, log_level.upper(), None)
    if not isinstance(numeric_level, int):
        print(f"Invalid log level: {log_level}")
        sys.exit(1)

    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(numeric_level)
    formatter = ColoredFormatter(
        '%(asctime)s [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)

    logging.basicConfig(
        level=numeric_level,
        handlers=[handler]
    )


def get_kernel_architecture():
    logging.debug("Fetching kernel CPU architecture...")
    try:
        result = subprocess.run(['uname', '-m'], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True, check=True)
        arch = result.stdout.strip()
        logging.info(f"Building for CPU architecture: {arch}")
        return arch
    except subprocess.CalledProcessError:
        logging.error("Error retrieving CPU architecture.")
        sys.exit(1)


########################
# Distrobox functions. #
########################

def check_distrobox_installed():
    try:
        run_distrobox_command(['distrobox', '--version'])
        logging.debug("Distrobox is installed.")
    except subprocess.CalledProcessError:
        logging.error("Error: 'distrobox' is not installed or not found in the host's $PATH.")
        sys.exit(1)


def run_distrobox_command(cmd):
    """
    If log level is DEBUG, captures and logs the output.
    Otherwise, captures stdout and stderr for error handling without displaying them.
    Returns subprocess.CompletedProcess.
    """
    try:
        result = subprocess.run(
            cmd,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            if result.stdout:
                logging.debug(f"Standard Output Stream:\n{result.stdout}")
            if result.stderr:
                logging.debug(f"Standard Error Stream:\n{result.stderr}")
        return result
    except subprocess.CalledProcessError as e:
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            if e.stdout:
                logging.debug(f"Standard Output Stream:\n{e.stdout}")
            if e.stderr:
                logging.debug(f"Standard Error Stream:\n{e.stderr}")
        logging.error(f"Command '{' '.join(cmd)}' failed with return code {e.returncode}")
        raise e


def generate_random_id(length=6):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))


def stop_and_remove_container(container_name, staging_dir=None):
    logging.info(f"Cleaning up container: {container_name}...")
    try:
        result = run_distrobox_command(['distrobox', 'list'])
        lines = result.stdout.splitlines()

        for line in lines:
            if container_name in line:
                container_id = line.split()[0]
                run_distrobox_command(['podman', 'container', 'kill', container_id])
                run_distrobox_command(['podman', 'container', 'rm', '-f', container_id])
                logging.info(f"Container '{container_name}' stopped and removed.")
                break
        else:
            logging.warning(f"Container '{container_name}' not found.")

        desktop_launcher = os.path.expanduser(f"~/.local/share/applications/{container_name}.desktop")
        if os.path.exists(desktop_launcher):
            try:
                os.remove(desktop_launcher)
                logging.info(f"Cleanup leftover launcher '{desktop_launcher}' deleted.")
            except OSError as e:
                logging.error(f"Failed to delete leftover launcher '{desktop_launcher}': {e}")
        else:
            logging.warning(f"Desktop launcher '{desktop_launcher}' not found.")

        if staging_dir and os.path.exists(staging_dir):
            try:
                shutil.rmtree(staging_dir)
                logging.info(f"Staging area '{staging_dir}' deleted.")
            except Exception as e:
                logging.critical(f"Error deleting staging area: {e}")

    except subprocess.CalledProcessError:
        logging.error(f"Error stopping and removing the container '{container_name}'.")
        desktop_launcher = os.path.expanduser(f"~/.local/share/applications/{container_name}.desktop")
        if os.path.exists(desktop_launcher):
            try:
                os.remove(desktop_launcher)
                logging.info(f"Cleanup leftover launcher'{desktop_launcher}' deleted.")
            except OSError as e:
                logging.error(f"Failed to delete leftover launcher '{desktop_launcher}': {e}")
        else:
            logging.warning(f"Desktop launcher '{desktop_launcher}' not found.")

        if staging_dir and os.path.exists(staging_dir):
            try:
                shutil.rmtree(staging_dir)
                logging.info(f"Staging area '{staging_dir}' deleted.")
            except Exception as e:
                logging.critical(f"Error deleting staging area: {e}")
        sys.exit(1)


#############################################################
# Step 1: Create a Distrobox container with a dynamic name. #
#############################################################

def create_distrobox_container(app_name):
    random_id = generate_random_id()
    container_name = f"{app_name}-{random_id}"
    logging.info(f"Creating Distrobox container: {container_name}...")
    try:
        run_distrobox_command([
            'distrobox', 'create', '-n', container_name, '-i', 'debian:stable',
            '--additional-packages', 'python3-pip fakeroot libglib2.0-bin squashfs-tools zsync git apt-file python3-yaml wget adwaita-icon-theme breeze-icon-theme oxygen-icon-theme tango-icon-theme'
        ])
        logging.info(f"Container '{container_name}' created and packages installed.")

        run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--', 'sudo', 'apt-file', 'update'
        ])

    except subprocess.CalledProcessError:
        logging.error(f"Error creating Distrobox container '{container_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)
    return container_name


#####################################################################
# Step 2: Install appimage-builder using pip3 inside the container. #
#####################################################################

def install_appimage_builder_in_container(container_name):
    logging.info(f"Installing appimage-builder in container: '{container_name}'...")
    try:
        run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'sudo', 'pip3', 'install', '--break-system-packages',
            'git+https://github.com/AppImageCrafters/appimage-builder.git'
        ])
        logging.info("appimage-builder installed successfully.")
    except subprocess.CalledProcessError:
        logging.error(f"Error installing appimage-builder in container '{container_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)


#################################################################
# Step 3: Get the application information using apt-cache show. #
#################################################################

def get_app_section(container_name, app_name):
    logging.debug(f"Fetching section for '{app_name}' from container: {container_name}...")
    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-cache', 'show', app_name
        ])
        for line in result.stdout.splitlines():
            if line.startswith("Section:"):
                section = line.split(":", 1)[1].strip()
                logging.debug(f"Detected section for '{app_name}': {section}")
                return section
        logging.error("Section not found.")
        stop_and_remove_container(container_name)
        sys.exit(1)
    except subprocess.CalledProcessError:
        logging.error(f"Error retrieving section for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)


def get_app_architecture(container_name, app_name):
    logging.debug(f"Fetching architecture for '{app_name}' from container: {container_name}'...")
    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-cache', 'show', app_name
        ])
        for line in result.stdout.splitlines():
            if line.startswith("Architecture:"):
                architecture = line.split(":", 1)[1].strip()
                logging.info(f"Detected package architecture for '{app_name}': {architecture}")
                return architecture
        logging.error("Architecture not found.")
        stop_and_remove_container(container_name)
        sys.exit(1)
    except subprocess.CalledProcessError:
        logging.error(f"Error retrieving architecture for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)


def get_app_version(container_name, app_name):
    logging.debug(f"Fetching version for '{app_name}' from container: {container_name}...")
    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-cache', 'show', app_name
        ])
        for line in result.stdout.splitlines():
            if line.startswith("Version:"):
                version = line.split(":", 1)[1].strip()
                logging.info(f"Detected version for '{app_name}': {version}")
                return version
        logging.error("Version not found.")
        stop_and_remove_container(container_name)
        sys.exit(1)
    except subprocess.CalledProcessError:
        logging.error(f"Error retrieving version for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)

def get_app_checksum(container_name, app_name):
    logging.debug(f"Fetching MD5 checksum for '{app_name}' from container: {container_name}...")
    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-cache', 'show', app_name
        ])
        for line in result.stdout.splitlines():
            if line.startswith("MD5sum:"):
                checksum = line.split(":", 1)[1].strip()
                logging.info(f"Detected MD5 checksum for '{app_name}': {checksum}")
                return checksum
        logging.error("MD5sum not found.")
        stop_and_remove_container(container_name)
        sys.exit(1)
    except subprocess.CalledProcessError:
        logging.error(f"Error retrieving MD5 checksum for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)


#####################################################################
# Step 4: Get the desktop and icon information using apt-file list. #
#####################################################################

def process_icons_and_desktop_files(container_name, app_name, staging_dir, exec_path):
    logging.debug(f"Processing icons and desktop files for '{app_name}'...")

    includes_icon = False
    includes_desktop = False
    icon_name = None

    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-file', 'list', app_name
        ])

        for line in result.stdout.splitlines():
            parts = line.split(':', 1)
            if len(parts) != 2:
                continue
            file_path = parts[1].strip()
            if not includes_icon:
                icon_extensions = ['.svg', '.png', '.xpm']
                if any('/icons/' in file_path and file_path.lower().endswith(ext) for ext in icon_extensions):
                    includes_icon = True
                    icon_file_name = os.path.basename(file_path)
                    icon_name, _ = os.path.splitext(icon_file_name)
                    logging.debug(f"Found icon file: {file_path}, icon_name: {icon_name}")
            if not includes_desktop:
                if file_path.startswith('/usr/share/applications/') and file_path.endswith('.desktop'):
                    includes_desktop = True
                    logging.debug(f"Found desktop launcher file: {file_path}")
            if includes_icon and includes_desktop:
                break

        logging.debug(f"Package '{app_name}' includes icon: {includes_icon}, includes desktop launcher: {includes_desktop}")

    except subprocess.CalledProcessError:
        logging.error(f"Error checking package files for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)

    if not includes_icon:
        logging.debug(f"No icon found for '{app_name}'. Downloading default icon...")
        icon_dest_dir = os.path.join(staging_dir, 'AppDir', 'usr', 'share', 'icons', 'hicolor', 'scalable', 'apps')
        try:
            os.makedirs(icon_dest_dir, exist_ok=True)
        except OSError as e:
            logging.error(f"Failed to create icon destination directory '{icon_dest_dir}': {e}")
            stop_and_remove_container(container_name, staging_dir)
            sys.exit(1)

        icon_name = app_name
        icon_dest_path = os.path.join(icon_dest_dir, f'{icon_name}.svg')
        default_icon_url = 'https://raw.githubusercontent.com/Nitrux/luv-icon-theme/refs/heads/master/Luv/mimetypes/64/application-x-iso9660-appimage.svg'
        try:
            run_distrobox_command([
                'distrobox', 'enter', '-n', container_name, '--',
                'wget', '-O', icon_dest_path, default_icon_url
            ])
            logging.debug(f"Default icon downloaded to {icon_dest_path}")
        except subprocess.CalledProcessError:
            logging.error(f"Failed to download default icon for '{app_name}'")
            stop_and_remove_container(container_name, staging_dir)
            sys.exit(1)

    if not includes_desktop:
        logging.debug(f"No desktop launcher found for '{app_name}'. Generating generic desktop launcher...")
        desktop_dir = os.path.join(staging_dir, 'AppDir', 'usr', 'share', 'applications')
        try:
            os.makedirs(desktop_dir, exist_ok=True)
        except OSError as e:
            logging.error(f"Failed to create desktop applications directory '{desktop_dir}': {e}")
            stop_and_remove_container(container_name, staging_dir)
            sys.exit(1)
        desktop_file_path = os.path.join(desktop_dir, f'{app_name}.desktop')

        desktop_entry = f"""[Desktop Entry]
Name={app_name}
Exec={exec_path}
Icon={icon_name}
Type=Application
Terminal=true
Categories=Utility;
"""
        try:
            with open(desktop_file_path, 'w') as desktop_file:
                desktop_file.write(desktop_entry)
            logging.debug(f"Generic desktop launcher created at '{desktop_file_path}'")
        except (OSError, IOError) as e:
            logging.error(f"Failed to create desktop launcher at '{desktop_file_path}': {e}")

    return icon_name


###############################################################
# Step 5: Get the path to the executable using apt-file list. #
###############################################################

def get_executable_path(container_name, app_name):
    logging.debug(f"Fetching executable path for '{app_name}' from container: {container_name}...")
    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-file', 'list', app_name
        ])

        exec_paths = []
        for line in result.stdout.splitlines():
            if ':' in line:
                _, file_path = line.split(':', 1)
                file_path = file_path.strip()
                if (file_path.startswith('/usr/bin/') or
                    file_path.startswith('/bin/') or
                    file_path.startswith('/usr/games/')):
                    exec_paths.append(file_path.lstrip('/'))

        if not exec_paths:
            fallback_exec_path = f"usr/bin/{app_name}"
            logging.warning(f"No executables found under '/usr/bin/', '/bin/', or '/usr/games/' for '{app_name}'. Falling back to '{fallback_exec_path}'.")
            return fallback_exec_path
        else:
            executable_names = [os.path.basename(path) for path in exec_paths]
            similarity_scores = [(name, difflib.SequenceMatcher(None, app_name, name).ratio()) for name in executable_names]
            similarity_scores.sort(key=lambda x: x[1], reverse=True)
            best_match_name, best_score = similarity_scores[0]
            logging.debug(f"Best match for '{app_name}' is '{best_match_name}' with similarity score {best_score:.2f}")
            for path in exec_paths:
                if os.path.basename(path) == best_match_name:
                    selected_path = path
                    logging.debug(f"Selected executable path: {selected_path}")
                    return selected_path
            logging.error(f"Executable '{best_match_name}' not found in paths.")
            stop_and_remove_container(container_name)
            sys.exit(1)
    except subprocess.CalledProcessError:
        logging.error(f"Error retrieving executable path for '{app_name}'.")
        stop_and_remove_container(container_name)
        sys.exit(1)


##########################################################################
# Step 6: Create a YAML recipe using a template and directory structure. #
##########################################################################

def create_staging_area(app_name, container_name):
    staging_dir = f"/tmp/{container_name}"
    try:
        os.makedirs(staging_dir, exist_ok=True)
        logging.debug(f"Staging area created at: '{staging_dir}'")
    except OSError as e:
        logging.error(f"Failed to create staging area '{staging_dir}': {e}")
        sys.exit(1)
    return staging_dir


def clean_staging_area(staging_dir):
    try:
        shutil.rmtree(staging_dir)
        logging.debug(f"Staging area '{staging_dir}' deleted.")
    except Exception as e:
        logging.critical(f"Error cleaning staging area: {e}")


class QuotedStr(str):
    pass

def quoted_str_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data, style="'")

yaml.SafeDumper.add_representer(QuotedStr, quoted_str_representer)

class LiteralStr(str):
    pass

def literal_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data)

yaml.SafeDumper.add_representer(LiteralStr, literal_representer)

def create_yaml_recipe(app_name, app_version, exec_path, container_name, staging_dir, app_architecture, kernel_architecture, icon_name):
    default_dependencies = ['bash', 'dash', app_name]

    appimage_builder_dir = os.path.join(staging_dir, f"{app_name}-appimage")
    try:
        os.makedirs(appimage_builder_dir, exist_ok=True)
        logging.debug(f"AppImage builder directory created at: {appimage_builder_dir}")
    except OSError as e:
        logging.error(f"Failed to create AppImage builder directory '{appimage_builder_dir}': {e}")
        stop_and_remove_container(container_name, staging_dir)
        sys.exit(1)

    recipe_path = os.path.join(appimage_builder_dir, f"{app_name}-appimage.yaml")

    repo_codename = 'stable'

    recipe = {
        'version': 1,
        'AppDir': {
            'path': './AppDir',
            'app_info': {
                'id': app_name,
                'name': app_name,
                'icon': icon_name,
                'version': app_version,
                'exec': exec_path,
                'exec_args': '$@'
            },
            'runtime': {
                'env': {
                    'PATH': QuotedStr('${APPDIR}/usr/bin:${APPDIR}/bin:${APPDIR}/usr/lib/{kernel_architecture}-linux-gnu/libexec/kf5:$PATH')
                }
            },
            'after_bundle': [
                "cd ./AppDir/usr/bin && ln -sf bash sh && cd -"
            ],
            'apt': {
                'arch': [app_architecture],
                'allow_unauthenticated': True,
                'sources': [
                    {
                        'sourceline': LiteralStr(f"deb [arch={app_architecture}] http://deb.debian.org/debian {repo_codename} main contrib non-free non-free-firmware"),
                        'key_url': 'https://ftp-master.debian.org/keys/archive-key-12.asc'
                    }
                ],
                'include': default_dependencies,
                'exclude': ['systemd']
            },
            'files': {
                'include': ['/usr/bin/which'],
                'exclude': [
                    'usr/include', 'usr/share/man', 'usr/share/doc', 'usr/share/doc/*/README.*',
                    'usr/share/doc/*/changelog.*', 'usr/share/doc/*/NEWS.*', 'usr/share/doc/*/TODO.*',
                    'lib/systemd', 'etc/systemd', 'usr/lib/systemd', 'usr/bin/systemd*',
                    'usr/bin/dpkg*', 'usr/bin/*-linux-gnu-*', 'usr/lib/*-linux-gnu/systemd',
                    'usr/bin/systemd-*', 'usr/share/locale'
                ]
            }
        },
        'AppImage': {
            'arch': kernel_architecture,
            'comp': 'xz',
            'file_name': f"{app_name}-{kernel_architecture}.AppImage",
            'update-information': f"gh-releases-zsync|Nitrux|{app_name}|{app_version}|*{kernel_architecture}.AppImage.zsync"
        }
    }

    try:
        with open(recipe_path, 'w') as yaml_file:
            yaml.dump(
                recipe,
                yaml_file,
                default_flow_style=False,
                sort_keys=False,
                indent=2,
                width=4096,
                allow_unicode=True,
                Dumper=yaml.SafeDumper
            )
        logging.debug(f"YAML recipe saved at: {recipe_path}")
    except (OSError, IOError) as e:
        logging.error(f"Failed to write YAML recipe to '{recipe_path}': {e}")
        stop_and_remove_container(container_name, staging_dir)
        sys.exit(1)

    return recipe_path


###############################################################################
# Step 7: Build AppImage inside the container and move to $HOME/Applications. #
###############################################################################

def build_appimage_in_container(container_name, app_name, recipe_path, staging_dir, exec_path, kernel_architecture):
    try:
        logging.info(f"Building AppImage for '{app_name}' using recipe at '{recipe_path}'...")

        run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--', 'bash', '-c',
            f'cd {staging_dir} && appimage-builder --recipe {recipe_path} --skip-tests'
        ])

        appimage_dir = os.path.expanduser("~/Applications")
        try:
            os.makedirs(appimage_dir, exist_ok=True)
        except OSError as e:
            logging.error(f"Failed to create Applications directory '{appimage_dir}': {e}")
            clean_staging_area(staging_dir)
            return False

        built_appimage = os.path.join(staging_dir, f"{app_name}-{kernel_architecture}.AppImage")

        if os.path.exists(built_appimage):
            destination_path = os.path.join(appimage_dir, f"{app_name}-{kernel_architecture}.AppImage")
            try:
                shutil.move(built_appimage, destination_path)
                logging.debug(f"AppImage moved to: {destination_path}")
                return True
            except (OSError, shutil.Error) as e:
                logging.error(f"Failed to move AppImage to '{destination_path}': {e}")
                return False
        else:
            logging.error(f"AppImage not found at {built_appimage}. Checking for subdirectories...")

            for root, dirs, files in os.walk(staging_dir):
                for file in files:
                    if file.endswith(f"{app_name}-{kernel_architecture}.AppImage"):
                        built_appimage = os.path.join(root, file)
                        destination_path = os.path.join(appimage_dir, file)
                        try:
                            shutil.move(built_appimage, destination_path)
                            logging.debug(f"AppImage found and moved to: {destination_path}")
                            return True
                        except (OSError, shutil.Error) as e:
                            logging.error(f"Failed to move AppImage to '{destination_path}': {e}")
                            return False

            logging.error("Error: AppImage not found after checking subdirectories.")
            return False

    except subprocess.CalledProcessError as e:
        stderr_output = e.stderr.strip()
        if "RuntimeError: Main executable is not an elf executable" in stderr_output:
            logging.error(f"Build failed for '{app_name}': Main executable is not an ELF executable.")
        elif f"No such file or directory: '{exec_path}'" in stderr_output:
            logging.error(f"Build failed for '{app_name}': Executable '{exec_path}' not found.")
        else:
            logging.error(f"Error building AppImage for '{app_name}': {stderr_output}")

        clean_staging_area(staging_dir)
        return False


##############################################################
# Step 8: Compute the checksum of the AppImage using SHA512. #
##############################################################

def compute_sha512(file_path):
    logging.info(f"Computing SHA512 checksum for '{file_path}'...")
    sha512 = hashlib.sha512()
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha512.update(chunk)
        checksum = sha512.hexdigest()
        logging.info(f"SHA512 checksum for '{file_path}': {checksum}")
        return checksum
    except IOError as e:
        logging.error(f"Failed to compute SHA512 checksum for '{file_path}': {e}")
        return "N/A"


###############################################################
# Step 9: Maintain a list of installed AppImages built by us. #
###############################################################

def update_installed_files(app_name, app_version, package_checksum, appimage_file, appimage_checksum):
    import os

    install_dir = os.path.expanduser("~/.local/share/nx-apphub")
    os.makedirs(install_dir, exist_ok=True)
    installed_files_path = os.path.join(install_dir, "installed_files")

    columns = ["Application", "Version", "Package Checksum (MD5)", "AppImage File", "AppImage Checksum (SHA512)"]
    new_entry = [app_name, app_version, package_checksum, appimage_file, appimage_checksum]
    fixed_lengths = [0, 0, 32, 0, 128]

    if not os.path.exists(installed_files_path) or os.path.getsize(installed_files_path) == 0:
        with open(installed_files_path, 'w') as f:
            f.write("| " + " | ".join(columns) + " |\n")
            f.write("|" + "|".join(['-' * (len(col)+2) for col in columns]) + "|\n")

    with open(installed_files_path, 'r') as f:
        lines = f.readlines()

    if len(lines) < 2:
        with open(installed_files_path, 'w') as f:
            f.write("| " + " | ".join(columns) + " |\n")
            f.write("|" + "|".join(['-' * (len(col)+2) for col in columns]) + "|\n")
        current_columns = columns
        max_lengths = [len(col) for col in columns]
    else:
        current_columns = lines[0].strip().split('|')[1:-1]
        data_lines = lines[2:]
        max_lengths = [len(col.strip()) if fixed_lengths[i] == 0 else fixed_lengths[i] for i, col in enumerate(current_columns)]

        for line in data_lines:
            parts = line.strip().split('|')[1:-1]
            for i, part in enumerate(parts):
                part = part.strip()
                if fixed_lengths[i] == 0:
                    max_lengths[i] = max(max_lengths[i], len(part))

        for i, item in enumerate(new_entry):
            if fixed_lengths[i] == 0:
                max_lengths[i] = max(max_lengths[i], len(item))

    header = "| " + " | ".join([columns[i].ljust(max_lengths[i]) for i in range(len(columns))]) + " |\n"
    separator = "|" + "|".join(['-' * (max_lengths[i]+2) for i in range(len(columns))]) + "|\n"

    with open(installed_files_path, 'w') as f:
        f.write(header)
        f.write(separator)
        for line in lines[2:]:
            parts = line.strip().split('|')[1:-1]
            formatted_line = "| " + " | ".join([
                parts[i].strip().ljust(max_lengths[i]) if fixed_lengths[i] == 0 else parts[i].strip()
                for i in range(len(parts))
            ]) + " |\n"
            f.write(formatted_line)
        formatted_new_line = "| " + " | ".join([
            new_entry[i].ljust(max_lengths[i]) if fixed_lengths[i] == 0 else new_entry[i]
            for i in range(len(new_entry))
        ]) + " |\n"
        f.write(formatted_new_line)


###################
# Build function. #
###################

def handle_build(app):
    app_name = app
    container_name = create_distrobox_container(app_name)
    try:
        install_appimage_builder_in_container(container_name)
        app_version = get_app_version(container_name, app_name)
        app_section = get_app_section(container_name, app_name)
        if app_section == 'metapackages':
            logging.error(f"Cannot build AppImage for '{app_name}' because it is a metapackage.")
            return (app_name, False)
        app_architecture = get_app_architecture(container_name, app_name)
        exec_path = get_executable_path(container_name, app_name)
        package_checksum = get_app_checksum(container_name, app_name)
        kernel_architecture = get_kernel_architecture()
        staging_dir = create_staging_area(app_name, container_name)

        icon_name = process_icons_and_desktop_files(container_name, app_name, staging_dir, exec_path)

        recipe_path = create_yaml_recipe(
            app_name, app_version, exec_path,
            container_name, staging_dir, app_architecture, kernel_architecture, icon_name
        )

        success = build_appimage_in_container(
            container_name, app_name, recipe_path, staging_dir, exec_path, kernel_architecture
        )
        if success:
            appimage_dir = os.path.expanduser("~/Applications")
            appimage_file = f"{app_name}-{kernel_architecture}.AppImage"
            appimage_path = os.path.join(appimage_dir, appimage_file)
            appimage_checksum = compute_sha512(appimage_path)
            update_installed_files(app_name, app_version, package_checksum, appimage_file, appimage_checksum)
        return (app_name, success)
    finally:
        stop_and_remove_container(container_name, staging_dir)


####################
# Remove function. #
####################

def handle_remove(apps):
    installed_files_path = os.path.expanduser("~/.local/share/nx-apphub/installed_files")
    applications_dir = os.path.expanduser("~/Applications")
    apps_removed = []
    apps_not_found = []

    if not os.path.exists(installed_files_path):
        logging.error(f"Installed files list not found at '{installed_files_path}'. Nothing to remove.")
        return False

    try:
        with open(installed_files_path, 'r') as f:
            lines = f.readlines()
    except IOError as e:
        logging.error(f"Failed to read installed files list: {e}")
        return False

    if len(lines) < 2:
        logging.error("Installed files list is empty. Nothing to remove.")
        return False

    headers = [header.strip() for header in lines[0].strip().strip('|').split('|')]
    data_entries = [line.strip().strip('|').split('|') for line in lines[2:]]

    installed_apps = []
    for entry in data_entries:
        if len(entry) != len(headers):
            continue
        app_dict = {headers[i]: entry[i].strip() for i in range(len(headers))}
        installed_apps.append(app_dict)

    fixed_lengths = [0, 0, 32, 0, 128]

    for app in apps:
        matched = False
        for installed_app in installed_apps:
            if installed_app['Application'] == app:
                matched = True
                appimage_file = installed_app['AppImage File']
                appimage_path = os.path.join(applications_dir, appimage_file)

                if os.path.exists(appimage_path):
                    try:
                        os.remove(appimage_path)
                        logging.info(f"Deleted AppImage: {appimage_path}")
                        apps_removed.append(app)
                    except OSError as e:
                        logging.error(f"Failed to delete AppImage '{appimage_path}': {e}")
                        apps_not_found.append(app)
                else:
                    logging.warning(f"AppImage file '{appimage_path}' does not exist.")
                    apps_not_found.append(app)

                installed_apps.remove(installed_app)
                break
        if not matched:
            logging.warning(f"Application '{app}' not found in installed files list.")
            apps_not_found.append(app)

    if not installed_apps:
        logging.warning("No AppImages remain after removal.")

    max_lengths = [0] * len(headers)
    for i, col in enumerate(headers):
        if fixed_lengths[i] > 0:
            max_lengths[i] = fixed_lengths[i]
        else:
            max_length = len(col)
            for app_entry in installed_apps:
                content_length = len(app_entry[col])
                if content_length > max_length:
                    max_length = content_length
            max_lengths[i] = max_length

    try:
        with open(installed_files_path, 'w') as f:
            header = "| " + " | ".join([headers[i].ljust(max_lengths[i]) for i in range(len(headers))]) + " |\n"
            f.write(header)
            separator = "|" + "|".join(['-' * (max_lengths[i] + 2) for i in range(len(headers))]) + "|\n"
            f.write(separator)
            for app_entry in installed_apps:
                row = "| " + " | ".join([
                    app_entry[col].ljust(max_lengths[i]) if fixed_lengths[i] == 0 else app_entry[col]
                    for i, col in enumerate(headers)
                ]) + " |\n"
                f.write(row)
    except IOError as e:
        logging.error(f"Failed to write updated installed files list: {e}")
        return False

    if apps_removed:
        logging.info(f"Successfully removed AppImage(s) for: {', '.join(apps_removed)}.")
    if apps_not_found:
        logging.warning(f"Could not remove AppImage(s) for: {', '.join(apps_not_found)}.")

    return len(apps_not_found) == 0


####################
# Update function. #
####################

def handle_update():
    installed_files_path = os.path.expanduser("~/.local/share/nx-apphub/installed_files")
    rollbacks_dir = os.path.expanduser("~/.local/share/nx-apphub/rollbacks")
    os.makedirs(rollbacks_dir, exist_ok=True)
    applications_dir = os.path.expanduser("~/Applications")
    all_success = True

    if not os.path.exists(installed_files_path):
        logging.error(f"Can't list installed applications '{installed_files_path}'.")
        return False

    try:
        with open(installed_files_path, 'r') as f:
            lines = f.readlines()
    except IOError as e:
        logging.error(f"Failed to list installed applications: {e}")
        return False

    if len(lines) < 2:
        logging.info("No AppImages to update.")
        return None

    headers = [header.strip() for header in lines[0].strip().strip('|').split('|')]
    data_entries = [line.strip().strip('|').split('|') for line in lines[2:]]

    installed_apps = []
    for entry in data_entries:
        if len(entry) != len(headers):
            continue
        app_dict = {headers[i]: entry[i].strip() for i in range(len(headers))}
        installed_apps.append(app_dict)

    if not installed_apps:
        logging.info("No AppImages to update.")
        return None

    app_names = [app['Application'] for app in installed_apps]
    container_name = create_distrobox_container("update")

    try:
        result = run_distrobox_command([
            'distrobox', 'enter', '-n', container_name, '--',
            'apt-cache', 'show'] + app_names
        )
    except subprocess.CalledProcessError:
        logging.error("Failed to retrieve package information for update.")
        stop_and_remove_container(container_name)
        sys.exit(1)

    package_info = {}
    current_app = None
    for line in result.stdout.splitlines():
        if line.startswith("Package:"):
            current_app = line.split(":", 1)[1].strip()
            package_info[current_app] = {}
        elif line.startswith("Version:") and current_app:
            package_info[current_app]['Version'] = line.split(":", 1)[1].strip()
        elif line.startswith("MD5sum:") and current_app:
            package_info[current_app]['MD5sum'] = line.split(":", 1)[1].strip()

    for app in installed_apps:
        app_name = app['Application']
        installed_version = app['Version']
        installed_md5 = app['Package Checksum (MD5)']
        current_version = package_info.get(app_name, {}).get('Version')
        current_md5 = package_info.get(app_name, {}).get('MD5sum')

        if not current_version or not current_md5:
            logging.warning(f"Package information for '{app_name}' is incomplete. Skipping update.")
            continue

        if installed_version != current_version or installed_md5 != current_md5:
            appimage_file = app['AppImage File']
            appimage_path = os.path.join(applications_dir, appimage_file)
            if os.path.exists(appimage_path):
                try:
                    os.chmod(appimage_path, 0o644)
                    backup_path = os.path.join(rollbacks_dir, f"{appimage_file}.bak")
                    shutil.move(appimage_path, backup_path)
                    logging.info(f"Moved existing AppImage to rollback: {backup_path}")
                except OSError as e:
                    logging.error(f"Failed to backup AppImage '{appimage_path}': {e}")
                    all_success = False
                    continue
            else:
                logging.warning(f"AppImage file '{appimage_path}' does not exist. Skipping backup.")

            success = handle_build(app_name)[1]
            if success:
                appimage_file_new = f"{app_name}-{get_kernel_architecture()}.AppImage"
                appimage_path_new = os.path.join(applications_dir, appimage_file_new)
                appimage_checksum = compute_sha512(appimage_path_new)
                app['Version'] = current_version
                app['Package Checksum (MD5)'] = current_md5
                app['AppImage Checksum (SHA512)'] = appimage_checksum
                logging.info(f"Updated AppImage for '{app_name}' successfully.")
            else:
                logging.error(f"Failed to update AppImage for '{app_name}'.")
                all_success = False

    stop_and_remove_container(container_name)

    try:
        with open(installed_files_path, 'w') as f:
            fixed_lengths = [0, 0, 32, 0, 128] 
            headers = [header.strip() for header in lines[0].strip().strip('|').split('|')]
            max_lengths = [len(col) if fixed_lengths[i] == 0 else fixed_lengths[i] for i, col in enumerate(headers)]
            for app_entry in installed_apps:
                for i, col in enumerate(headers):
                    if fixed_lengths[i] == 0:
                        max_lengths[i] = max(max_lengths[i], len(app_entry[col]))

            header = "| " + " | ".join([headers[i].ljust(max_lengths[i]) for i in range(len(headers))]) + " |\n"
            f.write(header)
            separator = "|" + "|".join(['-' * (max_lengths[i] + 2) for i in range(len(headers))]) + "|\n"
            f.write(separator)
            for app_entry in installed_apps:
                row = "| " + " | ".join([
                    app_entry[col].ljust(max_lengths[i]) if fixed_lengths[i] == 0 else app_entry[col]
                    for i, col in enumerate(headers)
                ]) + " |\n"
                f.write(row)
    except IOError as e:
        logging.error(f"Failed to write updated installed files list: {e}")
        return False

    return all_success


##################
# Main function. #
##################

def main():
    parser = CustomArgumentParser(
        description="""
NX Applications Hub——Locally built AppImages for Nitrux.

NX Applications Hub is a tool developed By Nitrux Latinoamericana S.C. to facilitate the creation and management of AppImages. 
Using Distrobox containers and appimage-builder, we generate portable and self-contained applications efficiently locally without external CI configuration.

This software is under the conditions of the BSD 3-Clause license.

        ⚠️ Important: This application was designed for Nitrux OS. Using it in other distributions may cause problems or not work at all. 
                     Please don't open issues about this; they will be closed.

If you encounter problems with this software, please create an issue.

©2024 Nitrux Latinoamericana S.C.
""",
    )

    subparsers = parser.add_subparsers(dest='command', required=True)

    install_parser = subparsers.add_parser(
        'install',
        help='Build AppImage(s) for specified application(s).'
    )

    install_parser.add_argument(
        'apps',
        type=str,
        nargs='+',
        help='Name(s) of the application(s) for which to build AppImage(s).'
    )

    install_parser.add_argument(
        '-l', '--log-level',
        type=str,
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        default='INFO',
        help='Logging level {DEBUG,INFO,WARNING,ERROR,CRITICAL} (default: INFO).'
    )

    install_parser.add_argument(
        '-p', '--parallel',
        type=int,
        default=1,
        help='Number of parallel builds to run (default: 1).'
    )

    remove_parser = subparsers.add_parser(
        'remove',
        help='Remove specified AppImage(s).'
    )

    remove_parser.add_argument(
        'apps',
        type=str,
        nargs='+',
        help='Name(s) of the application(s) to remove AppImage(s) for.'
    )

    remove_parser.add_argument(
        '-l', '--log-level',
        type=str,
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        default='INFO',
        help='Logging level {DEBUG,INFO,WARNING,ERROR,CRITICAL} (default: INFO).'
    )

    update_parser = subparsers.add_parser(
        'update',
        help='Update all existing AppImage(s).'
    )

    update_parser.add_argument(
        '-l', '--log-level',
        type=str,
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        default='INFO',
        help='Logging level {DEBUG,INFO,WARNING,ERROR,CRITICAL} (default: INFO).'
    )

    try:
        args = parser.parse_args()

        if args.command in ['install', 'remove', 'update']:
            setup_logging(args.log_level)

        check_distrobox_installed()

        build_tasks = []
        all_success = True

        if args.command == 'install':
            for app in args.apps:
                app = app.strip()
                if app.startswith('lib') or app.endswith('-dev'):
                    logging.error(f"Invalid application name '{app}'. Libraries and development packages cannot be built as AppImages.")
                    all_success = False
                    continue
                build_tasks.append(app)

            if not build_tasks:
                logging.error("No valid applications to build. Exiting.")
                sys.exit(1)

            with ThreadPoolExecutor(max_workers=args.parallel) as executor:
                future_to_app = {
                    executor.submit(handle_build, app): app
                    for app in build_tasks
                }
                for future in as_completed(future_to_app):
                    app = future_to_app[future]
                    try:
                        app_name, success = future.result()
                        if success:
                            logging.info(f"AppImage for '{app_name}' built successfully.")
                        else:
                            logging.error(f"AppImage for '{app_name}' failed to build.")
                            all_success = False
                    except Exception as exc:
                        logging.critical(f"AppImage for '{app}' generated an exception: {exc}")
                        all_success = False

            if all_success:
                logging.info("All build processes completed.")
            else:
                logging.warning("AppImage(s) build processes failed. Check the logs for details.")

        elif args.command == 'remove':
            apps_to_remove = args.apps
            remove_success = handle_remove(apps_to_remove)
            if remove_success:
                logging.info("AppImage(s) removed successfully.")
            else:
                logging.warning("AppImage(s) could not be removed. Check the logs for details.")

        elif args.command == 'update':
            update_success = handle_update()
            if update_success is True:
                logging.info("AppImage(s) updated successfully.")
            elif update_success is None:
                logging.info("No AppImages were updated.")
            else:
                logging.warning("Some AppImage(s) failed to update. Check the logs for details.")

    except Exception as e:
        logging.critical(f"An unexpected error occurred: {e}")
        sys.exit(1)


########################
# Execute the program. #
########################

if __name__ == "__main__":
    main()
